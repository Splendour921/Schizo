let audioContext;
        let isPlaying = false; // Tracks if the chaotic sound is playing
        const backgroundMusic = document.getElementById('backgroundMusic');

        // Function to stop the background music
        function stopBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.pause();
                backgroundMusic.currentTime = 0; // Reset to the beginning
                console.log("Background music stopped.");
            }
        }

        // Array to hold all active floating emoji objects
        const floatingEmojis = [];
        const emojiList = [
            '🍬', '🍫', '🍭', '🍩', '🤪', '🤯', '😵‍💫', '🫠', '👁️', '👀', '👁️‍🗨️',
            '🌀', '⚡', '👾', '❓', '❕', '👽', '🛸', '🌟', '💫', '🥜', '🌈',
            '💊', '☠️', '👻', '⏳', '🔮', '🎭'
        ];

        // --- NEW: Dynamic Emoji Limits ---
        let MAX_FLOATING_EMOJIS; // This will be set based on screen size
        const INITIAL_EMOJI_LIMIT_PHONE = 6;
        const BUTTON_EMOJI_LIMIT_PHONE = 12;

        // Function to remove oldest emoji if we exceed MAX_FLOATING_EMOJIS
        function cleanupEmojis() {
            while (floatingEmojis.length > MAX_FLOATING_EMOJIS) {
                const oldestMeme = floatingEmojis.shift(); // Remove from the beginning of the array
                if (oldestMeme && oldestMeme.parentNode) {
                    oldestMeme.parentNode.removeChild(oldestMeme);
                }
            }
        }

        // Function to handle the initial gate acceptance
        function acceptGate() {
            const initialGate = document.getElementById('initialGate');
            const mainContent = document.getElementById('mainContent');

            // --- NEW: Set initial emoji limit based on screen width ---
            if (window.innerWidth <= 768) { // Assuming 768px as phone breakpoint
                MAX_FLOATING_EMOJIS = INITIAL_EMOJI_LIMIT_PHONE;
            } else {
                // For larger screens, set a higher default if needed, or keep it at 15
                MAX_FLOATING_EMOJIS = 15; // Or whatever default you want for desktop
            }
            console.log("Initial MAX_FLOATING_EMOJIS:", MAX_FLOATING_EMOJIS);

            // Hide the gate with animation
            initialGate.classList.add('hidden');
            
            // Show main content after the fade-out
            setTimeout(() => {
                initialGate.style.display = 'none';
                mainContent.style.display = 'block'; // Show the main content

                // Attempt to play background music on user interaction
                if (backgroundMusic) {
                    backgroundMusic.volume = 0.3; // Set a subtle volume
                    backgroundMusic.play().catch(error => {
                        console.log("Background music autoplay prevented:", error);
                    });
                }

                // Initialize AudioContext and ensure it's resumed for Web Audio API sounds
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed successfully after gate entry.');
                    }).catch(err => {
                        console.error('Error resuming AudioContext:', err);
                    });
                }
                
                // Start spawning floating memes periodically
                // This interval will now only add if below MAX_FLOATING_EMOJIS
                setInterval(createFloatingMeme, 300); // Spawn a new meme every 300ms

                // Start the animation loop for the emojis
                animateEmojis();

                // Immediately create emojis up to the initial limit
                while(floatingEmojis.length < MAX_FLOATING_EMOJIS) {
                    createFloatingMeme();
                }

            }, 500); // Matches the fadeOut animation duration
        }
        
        function activateSchizo() {
            showPopup('seuePopupContainer'); // Show the first popup
            
            // Ensure AudioContext is resumed before playing chaotic sound
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully for schizo sound.');
                    if (!isPlaying) {
                        playSchizophrenicSound();
                        isPlaying = true;
                    }
                }).catch(err => {
                    console.error('Error resuming AudioContext for schizo sound:', err);
                });
            } else if (!isPlaying) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                playSchizophrenicSound();
                isPlaying = true;
            }
            
            // --- NEW: Increase emoji limit on button click for phones ---
            if (window.innerWidth <= 768) {
                MAX_FLOATING_EMOJIS = BUTTON_EMOJI_LIMIT_PHONE;
                console.log("MAX_FLOATING_EMOJIS updated to:", MAX_FLOATING_EMOJIS, "on button click.");
                
                // Immediately create new emojis until the new limit is reached
                // This ensures the 12 emojis appear quickly after click.
                const emojisToAdd = MAX_FLOATING_EMOJIS - floatingEmojis.length;
                for (let i = 0; i < emojisToAdd; i++) {
                    // Slight delay for visual effect, but still fast
                    setTimeout(() => createFloatingMeme(), i * 50); 
                }
            }
        }
        
        function playSchizophrenicSound() {
            if (!audioContext) {
                console.error("AudioContext is not initialized. Cannot play schizophrenic sound.");
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.5);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 1);
            
            const noise = audioContext.createOscillator();
            const noiseGain = audioContext.createGain();
            noise.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            
            noise.frequency.setValueAtTime(Math.random() * 1000 + 500, audioContext.currentTime);
            noiseGain.gain.setValueAtTime(0.05, audioContext.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            noise.start(audioContext.currentTime);
            noise.stop(audioContext.currentTime + 0.3);

            setTimeout(() => { isPlaying = false; }, 1000); // Allow sound to play again after 1 second
        }
        
        function createFloatingMeme() {
            // --- NEW: Only create if current count is less than MAX_FLOATING_EMOJIS ---
            if (floatingEmojis.length < MAX_FLOATING_EMOJIS) {
                const meme = document.createElement('div');
                meme.className = 'floating-memes';
                meme.textContent = emojiList[Math.floor(Math.random() * emojiList.length)];
                
                const size = 20 + Math.random() * 20; 
                meme.style.fontSize = size + 'px';

                meme.x = Math.random() * (window.innerWidth - size);
                meme.y = Math.random() * (window.innerHeight - size);

                meme.style.left = meme.x + 'px';
                meme.style.top = meme.y + 'px';

                meme.speedX = (Math.random() - 0.5) * 3; 
                meme.speedY = (Math.random() - 0.5) * 3;

                meme.rotation = Math.random() * 360; 
                meme.rotationSpeed = (Math.random() - 0.5) * 1; 
                
                document.body.appendChild(meme);
                floatingEmojis.push(meme);
            } else {
                // If we are at or above the limit, ensure cleanup is called
                cleanupEmojis();
            }
        }

        function animateEmojis() {
            floatingEmojis.forEach(meme => {
                meme.x += meme.speedX;
                meme.y += meme.speedY;
                meme.rotation += meme.rotationSpeed;

                if (meme.x > window.innerWidth) meme.x = -meme.offsetWidth;
                if (meme.x < -meme.offsetWidth) meme.x = window.innerWidth;
                if (meme.y > window.innerHeight) meme.y = -meme.offsetHeight;
                if (meme.y < -meme.offsetHeight) meme.y = window.innerHeight;

                meme.style.left = meme.x + 'px';
                meme.style.top = meme.y + 'px';
                meme.style.transform = `rotate(${meme.rotation}deg)`;
            });
            requestAnimationFrame(animateEmojis);
        }

        function showPopup(id) {
            const popup = document.getElementById(id);
            if (popup) {
                popup.classList.remove('hidden');
            }
        }

        function hidePopup(id) {
            const popup = document.getElementById(id);
            if (popup) {
                popup.classList.add('hidden');
            }
        }

        window.onload = function() {
            // Any initial setup on load if needed, but gate handles entry logic
        };

        // --- NEW: Handle window resize to adjust emoji limit dynamically if breakpoint is crossed ---
        // This is important if a user resizes their browser window from desktop to phone size
        // or vice-versa while on the page.
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const newWidth = window.innerWidth;
                const isPhoneSize = newWidth <= 768;
                let newMaxEmojis;

                // Determine the new maximum based on current state (button clicked or not)
                // This assumes `MAX_FLOATING_EMOJIS` stores the *current* target.
                // If you want to strictly enforce initial/button limits on resize,
                // you might need a flag to track if the button was clicked.
                if (isPhoneSize) {
                    // If button was clicked and now resize to phone size, maybe keep 12
                    // For simplicity, let's reset to initial limit for phones on resize
                    // unless a more complex state management is implemented.
                    newMaxEmojis = INITIAL_EMOJI_LIMIT_PHONE;
                } else {
                    newMaxEmojis = 15; // Desktop default
                }

                if (MAX_FLOATING_EMOJIS !== newMaxEmojis) {
                    MAX_FLOATING_EMOJIS = newMaxEmojis;
                    console.log("Resized, MAX_FLOATING_EMOJIS adjusted to:", MAX_FLOATING_EMOJIS);
                    // Immediately clean up or create to meet the new limit
                    cleanupEmojis(); 
                    while(floatingEmojis.length < MAX_FLOATING_EMOJIS) {
                        createFloatingMeme();
                    }
                }
            }, 250); // Debounce resize event
        });
